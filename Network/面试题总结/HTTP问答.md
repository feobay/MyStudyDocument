# HTTP



## 1.HTTP是什么？

HTTP，全称Hyper Text Transfer Protocol，超文本传输协议。顾名思义，它就是在计算机世界中两点之间传输 文字、音频、视频 等 超文本 数据的 规范和约定。



## 2.HTTP常见状态码有什么

有**1、2、3、4、5开头的状态码**

- **1开头的的状态码通常表示提示信息**，表示协议处理的中间状态
- **2开头的状态码表示成功**，如
  - **200 OK**，表示一切正常，如果时非 `HEAD` 请求通常还带有body数据
  - **204 No Content**，表示响应头没有body数据
  - **206 Partial Content**，表示响应返回的body数据并非请求资源的全部，而是其中一部分，也属于服务器处理成功的状态，一般用于**HTTP分块下载**或**断点续传**
- **3开头的状态码表示重定向**，如
  - **301 Moved Permanently， 永久重定向，**请求资源已经不存在，要更换url再次访问
  - **302 Found，临时重定向**，临时更换url
    - 301和302都在响应头里使用字段 `Location`，指明后续要跳转的url，浏览器会自动重定向至该url
  - **304 Not Modified，缓存重定向**，不具有跳转含义，表示资源未修改，重定向缓存文件
- **4开头的状态码表示客户端发送报文有误**，是错误码
  - **400 Bad request**，表示客户端请求的报文有错误，但是个笼统的错误
  - **403 Forbidden**，表示服务器禁止访问资源，并不是客户端请求出错
  - **404 Not Found**，表示请求的资源在服务器中不存在或未找到，所以无法提供给客户端
- **5开头的状态码表示服务器处理报文时内部发生了错误**，服务端错误码
  - **500 Internal Server Error**，表示服务器错误，但是个笼统的描述，并不解释原因
  - **501 Not Implement**，表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思
  - **502 Bad Gateway**，通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生错误。
  - **503 Service Unavailable**，表示服务器忙，暂时无法响应客户端



## 3.HTTP常见字段有哪些

- **host**字段，客户端请求时指定服务器域名
- **Content-length**字段，响应报文中表示本次回应数据长度
- **Connection**字段，是否启用HTTP长连接（Keep-Alive）
- **Content-Type**字段，服务端响应时表明本次响应的数据格式
- **Accept**字段，客户端请求时表示自己可接受的数据格式
- **Content-Encoding**字段，服务器响应数据时，说明数据的压缩方法。
- **Accept-Encoding** 字段，说明自己可以接受哪些压缩方法。





## 4.GET和POST有哪些区别

- 首先语义不同
  - **GET**，从服务器获取指定资源；
  - **POST**，根据请求报文的body数据对指定资源做出处理。
    - 当然开发者可以不遵守这个规定自己决定如何处理。

- 其次在安全、幂等性和可缓存方面不同
  - **安全**：指请求不会破坏计算机资源
  - **幂等**：表示无论多少次请求都会得到相同结果
  - **GET方法安全且幂等可缓存**，因为它只读。
  - POST方法不安全不幂等，因为它是新增和提交数据操作

**总结**（回答时直接这样答）

GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。

POST 的语义是根据请求报文的body对指定的资源做出处理。POST 不安全，不幂等，（大部分实现）不可缓存。



## 5.HTTP缓存有哪些实现方式

强制缓存和协商缓存。



## 6.什么是强制缓存

强制缓存是指只要浏览器缓存的数据没有过期，就从浏览器这边获取缓存数据，选择是否使用缓存是由浏览器决定的。



## 7.强制缓存如何实现的

强制缓存是靠 两个响应头部字段实现的

-  `Cache-Control`，相对时间
- `Expires`，绝对时间

如果同时有这两个字段，那么`Cache-control`的优先级高于Expires。

服务器首次收到请求时在响应报文中添加 `Cache-control`字段；浏览器根据发起请求时间及`Cache-control`大小计算过期时间，未过期使用缓存，过期则再次请求；服务器再次收到请求在响应时更新 `Cache-control`.

> Expries就是到达预设时间缓存过期。
>
> Cache-control的选项更多，设置更精细，所以更推荐使用。其实现流程如下：
>
> - 浏览器第一次请求服务器时，服务器在响应报文中添加 `Cache-control` 字段，设置过期时间大小
> - 当浏览器再次请求时，浏览器通过请求时间和设置的过期时间大小计算出过期时间，若未过期直接使用缓存，若过期则重新请求服务器
> - 服务器再次收到请求后，会重新设置Response头部的 `Cache-control` 大小



## 8.什么是协商缓存

协商缓存就是与服务端协商之后，通过协商结果判断是否使用本地缓存。



## 9.如何实现协商缓存

记住两个东西：Last Modified 和 Etag

1. 通过请求头中的 <font color="red">`If-Modified-Since` </font>字段与响应头部中的<font color="red"> `Last-Modified` </font> 字段实现，这两个字段的意思是：

- 响应头部的 `Last-Modified`: 标识被请求资源的最后修改时间
- 请求头部的 `If-Modified-Since`: 当浏览器发现收到的响应报文中有 `Last-Modified`字段时，就会在下一次请求时将 `If-Modified-Since`字段设置为收到的 `Last-Modified` 的值，服务器收到请求后，将请求报文中的`If-Modified-Since` 字段与本地资源最后修改时间对比（`Last-Modified` ），如果最后修改比较大，说明资源被修改过，返回新资源，响应HTTP 200 OK；若最后修改小于等于 `If-Modified-Since` 字段，那么说明资源无修改，响应 HTTP 304 走缓存。

2. 通过请求头中的<font color="red"> `If-None-Match` </font> 字段与响应头中的<font color="red"> `Etag` </font>字段对比，这两个字段意思是：

- 响应头部中 `Etag`: 唯一标识响应资源。
- 请求头部中的  `If-None-Match` ：当**资源过期时**，浏览器发现响应头里有`Etag`，则再次向服务器发起请求时，会将请求头 `If-None-Match` 值设置为 `Etag` 的值。服务器收到请求后进行对比，如果资源没有变化返回HTTP 304 No Modified，变化了返回 HTTP 200 OK

第一种是基于**修改时间**，第二种是基于**文件唯一标识**

**如果同时有Etag和Last-Modified，那么Etag优先**

<font color="steelblue">**PS：协商缓存这两个字段都必须配合 `Cache-control` 字段使用，只有未命中强制缓存时，才能发起带有协商缓存字段的请求。**</font>

![http缓存](assets/http缓存.png)



## 10.HTTP/1.1有哪些优点

1.首先是**简单**，基本报文结构为 `Header + body`，信息也是 `key-value` 的形式，易于理解

2.其次是**灵活易于扩展**，HTTP里的各类请求方法、URI/URL、状态码等未和固定死，允许开发人员**自定义和扩充**。并且因为HTTP工作在应用层， **下层可以随意变化**，比如：HTTPS就是在HTTP和TCP层之间添加了SSL/TLS层；再比如HTTP/1.1和HTTP/1.2用的TCP，到HTTP/3.0用的UDP

3.**应用广泛和跨平台**



## 11.HTTP/1.1的缺点

1.**无状态导致进行关联性操作时会比较麻烦**，比如每次添加购物车、下单等操作每次都要验证身份；可通过 **cookie** 解决。

2.**不安全**，**明文传输**导致信息泄露；**不验证通信方身份**，可能遭遇伪装（钓鱼网站）；**不能验证报文完整性**，报文可能遭篡改，导致访问的网站被植入各种垃圾广告。



## 12.HTTP/1.1性能

HTTP协议是基于 TCP/IP，并且使用了 **请求-应答** 的通信模式，所以性能的关键就在这两点。

为了提升性能：

1.**长连接**：HTTP1.0每请求应答一次就要进行一次TCP握手和挥手，长连接就是让一次TCP连接在最后一次HTTP请求响应结束后继续存在一段时间，等到期断开连接，如果在该连接上又有新的请求响应则重新更新连接过期时间。

2.**管道传输**：也就是说，在一个TCP连接里，第一个请求发出去了不必等待其响应报文到达，就可以发送第二个请求。减少整体响应时间。

3.**队头阻塞**：浏览器端请求可以管道传输，但是在 **服务器必须按照请求的顺序处理响应**，如果前面的请求（比如A）比较耗时，那么处在请求队列后面的请求就会等待较长时间，这就是**队头阻塞**，HTTP1.1解决了请求的队头阻塞，但是没有解决响应的**队头阻塞**。

>  PS: HTTP1.1管道化技术不是默认开启的



## 13.HTTP和HTTPS的区别

- **HTTP明文传输**，**HTTPS**在HTTP和TCP之间加了一层SSL/TLS层，使得报文可以**加密传输**。
- **HTTP连接建立简单**，TCP三次握手后即可传输报文，而**HTTPS**在**TCP三次握手** + **SSL/TLS 握手** 后，才可以进入加密报文传输。
- **两者默认端口不一样**，**HTTP**默认端口号是**80**，**HTTPS**默认端口号是**443**
- HTTPS协议需要向 **CA**（证书权威机构）申请数字证书，来保证服务器的身份是可信的。



## 14.HTTPS解决了HTTP的哪些问题

HTTP是明文传输，所以安全上存在以下风险：

- **窃听风险**，信息泄露
- **篡改风险**，网站被植入垃圾信息
- **冒充风险**，假冒网站

而HTTPS在HTTP和 TCP之间加了 SSL/TLS 协议，解决了上述风险。

- **信息加密**：解决窃听
- **校验机制**：保证报文完整性，防止篡改
- **身份证书**：验证身份，防止假冒网站



## 15.HTTPS如何解决上述问题（SSL/TLS的原理）

- **混合加密**实现信息的**机密性**，解决窃听风险
- **摘要算法**保证信息**完整性**+**数字签名**，为数据生成独一无二的指纹用于校验，数字签名确保信息来源。
- 将服务器公钥放入 **数字证书** 中，解决冒充。



<font color="red">**1.混合加密**</font>

HTTPS 采用 **对称加密** 和 **混合加密** 方式：

- 在通信建立前采用 **非对称加密** 的方式交换会话密钥
- 在通信过程中全部采用**对称加密**的会话密钥

采用对称加密的原因：

- **对称加密**只使用一个密钥，运算速度快，密钥必须保密
- **非对称加密**使用两个密钥：公钥和私钥，公钥可任意分发而私钥必须保密，解决密钥交换问题但是速度慢



<font color="red">**2.摘要算法+数字签名**</font>

**摘要算法**：**计算出内容的哈希值**，用来唯一标识该内容，**并且这个哈希值是唯一的，且无法通过哈希值推导内容。**

![摘要算法](assets/摘要算法.png)

**数字签名算法**

要注意的是，哈希算法可以保证内容不被篡改，**但是不能保证 内容+哈希值 不被替换，因为没有客户端收到的消息是否来自服务端的证明。**

为避免被替换，会使用 **非对称加密算法**解决（包含公钥私钥）

**非对称算法**是可以双向加解密的

- **公钥加密，私钥解密**，**保证信息不泄露**，因为只有持有私钥的人才能解密。
- **私钥加密，公钥解密**，**保证消息不被冒充**，因为私钥不可泄漏，如果公钥能正常解密出信息，那么就说明该消息来源于私钥持有人。

非对称加密一半不会用于加密传输信息，因为比较消耗计算机资源，所以一般只是作为数字签名算法来确保消息来源正常。

**数字签名算法**：就是**私钥加密，公钥解密**，这样可以确保消息不被冒充。不过一般是**加密哈希值而非内容本身**。



**总结：哈希算法防止消息被篡改，签名算法（公钥加密，私钥解密）防消息冒充。**



<font color="red">**3.数字证书**</font>

哈希算法防篡改、数字签名确认消息来自于私钥持有者。

但是，公钥可能被伪造。**攻击者可以伪造一对 公私钥对，并偷偷替换浏览器存储的公钥，达到冒充消息的效果。**

所以 **公钥 **需要注册到 **CA（Certificate Authority，数字证书认证机构）**，CA会使用**CA内部的私钥**对**服务器的公钥**做个数字签名，然后将 **服务器公钥+数字签名** 打包成 **数字证书**，以便未来请求服务的一方来验证身份，**如果使用CA的公钥能够解密成功，就说明这个数字证书是合法的。（CA的公钥一半已经事先置入到了浏览器或者操作系统里。）**

**CA证书工作流程**

- 服务器将公钥注册到CA
- CA用自己的私钥将服务器的公钥数字签名并颁发数字证书（包含服务器公钥+数字签名）
- 客户端拿到服务器的数字证书后，使用原先内置于浏览器或操作系统的CA公钥确认服务器给的数字证书真实性
- 客户端使用服务器的公钥对要传输的数据进行加密
- 服务器使用自己的私钥对传输的数据进行解密

![数字证书工作流程](assets/数字证书工作流程.png)



## 16.HTTPS如何建立？

SSL/TLS 协议基本流程：

- 客户端向服务器索要并验证服务器的公钥
- 双方协商生产 会话密钥
- 双方采用会话密钥进行加密通信

前两步是 SSL/TLS 会话建立过程，也叫 **TLS握手**阶段。

TLS握手涉及四个阶段，使用不同密钥交换算法，TLS握手流程也不一样，现在通常使用密钥交换算法有两种：**RSA** 和 **ECDHE**。















